## 构造函数
- 成员函数的一种
  - 名字与类名相同，可以有参数，不能有返回值(void也不行)
  - 作用是对对象进行初始化，如给成员变量赋初值
  - 如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数; 默认构造函数无参数，不做任何操作
  - 如果定义了构造函数，则编译器不生成默认的无参数的构造函数
  - 对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数
  - 一个类可以有多个构造函数
- 为什么需要构造函数
  - 构造函数执行必要的初始化工作，有了构造函数，就不必专门再写初始化函数，也不用担心忘记调用初始化函数。
  - 有时对象没被初始化就使用，会导致程序出错。

## 复制构造函数(copy constructor)
- 只有一个参数,即对同类对象的引用。
- 形如X::X( X& )或X::X(const X &), 二者选一后者能以常量对象作为参数
- 如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能

- 复制构造函数起作用的三种情况
  - 当用一个对象去初始化同类的另一个对象时。
  ```
  Complex c2(c1);
  Complex c2 = c1; //初始化语句，非赋值语句
  ```
  
  - 如果某函数有一个参数是类A 的对象，那么该函数被调用时，类A的复制构造函数将被调用
  - 如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用

## 静态成员变量和静态成员函数
- 静态成员：在说明前面加了static关键字的成员。
- 普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享
- 普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用与某个对象
- 因此静态成员不需要通过对象就能访问
- sizeof运算符不会计算静态成员变量

- 静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在
- 静态成员函数本质上是全局函数
- 设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解

- 在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数

## 成员对象和封闭类
- 成员对象:一个类的成员变量是另一个类的对象
- 包含成员对象的类叫封闭类(Enclosing)
- 生成封闭类对象的语句->明确“对象中的成员对象”->如何初始化
- 定义封闭类的构造函数时, 添加初始化列表

- 当封闭类对象生成时
  - S1: 执行所有成员对象的构造函数
  - S2: 执行封闭类的构造函数成员对象的构造函数
  - 调用顺序和成员对象在类中的说明顺序一致,与在成员初始化列表中出现的顺序无关当
- 封闭类的对象消亡时
  - S1: 先执行封闭类的析构函数
  - S2: 执行成员对象的析构函数析构函数顺序和构造函数的调用顺序相反
  
## 友元(Friend)
- 一个类的友元函数可以访问该类的私有成员
- 将一个类的成员函数(包括构造, 析构函数)->另一个类的友元
- A是B的友元类->A的成员函数可以访问B的私有成员
- Note:友元类之间的关系不能传递, 不能继承

## this 指针
- 其作用就是指向成员函数所作用的对象
- 非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针
- this指针和静态成员函数
  - 静态成员函数中不能使用this 指针！
  - 因为静态成员函数并不具体作用与某个对象!因此，静态成员函数的真实的参数的个数，就是程序中写出的参数个数
  
## 常量对象、常量成员函数和常引用
- 如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加const关键字
- 在类的成员函数说明后面可以加const关键字，则该成员函数成为常量成员函数
- 常量成员函数执行期间不应修改其所作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数(静态成员函数除外）
- 两个成员函数，名字和参数表都一样，但是一个是const,一个不是，算重载

- 引用前面可以加const关键字，成为常引用。不能通过常引用，修改其引用的变量

## 运算符重载
- 对已有的运算符赋予多重的含义
- 使同一运算符作用于不同类型的数据时->不同类型的行为
- 运算符重载的实质是函数重载
