## 构造函数
- 成员函数的一种
  - 名字与类名相同，可以有参数，不能有返回值(void也不行)
  - 作用是对对象进行初始化，如给成员变量赋初值
  - 如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数; 默认构造函数无参数，不做任何操作
  - 如果定义了构造函数，则编译器不生成默认的无参数的构造函数
  - 对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数
  - 一个类可以有多个构造函数
- 为什么需要构造函数
  - 构造函数执行必要的初始化工作，有了构造函数，就不必专门再写初始化函数，也不用担心忘记调用初始化函数。
  - 有时对象没被初始化就使用，会导致程序出错。

## 复制构造函数(copy constructor)
- 只有一个参数,即对同类对象的引用。
- 形如X::X( X& )或X::X(const X &), 二者选一后者能以常量对象作为参数
- 如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能

- 复制构造函数起作用的三种情况
  - 当用一个对象去初始化同类的另一个对象时。
  ```
  Complex c2(c1);
  Complex c2 = c1; //初始化语句，非赋值语句
  ```
  
  - 如果某函数有一个参数是类A 的对象，那么该函数被调用时，类A的复制构造函数将被调用
  - 如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用

## 静态成员变量和静态成员函数
- 静态成员：在说明前面加了static关键字的成员。
- 普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享
- 普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用与某个对象
- 因此静态成员不需要通过对象就能访问
- sizeof运算符不会计算静态成员变量

- 静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在
- 静态成员函数本质上是全局函数
- 设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解

- 在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数

## 成员对象和封闭类
- 成员对象:一个类的成员变量是另一个类的对象
- 包含成员对象的类叫封闭类(Enclosing)
- 生成封闭类对象的语句->明确“对象中的成员对象”->如何初始化
- 定义封闭类的构造函数时, 添加初始化列表

- 当封闭类对象生成时
  - S1: 执行所有成员对象的构造函数
  - S2: 执行封闭类的构造函数成员对象的构造函数
  - 调用顺序和成员对象在类中的说明顺序一致,与在成员初始化列表中出现的顺序无关当
- 封闭类的对象消亡时
  - S1: 先执行封闭类的析构函数
  - S2: 执行成员对象的析构函数析构函数顺序和构造函数的调用顺序相反
  
## 友元(Friend)
- 一个类的友元函数可以访问该类的私有成员
- 将一个类的成员函数(包括构造, 析构函数)->另一个类的友元
- A是B的友元类->A的成员函数可以访问B的私有成员
- Note:友元类之间的关系不能传递, 不能继承

## this 指针
- 其作用就是指向成员函数所作用的对象
- 非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针
- this指针和静态成员函数
  - 静态成员函数中不能使用this 指针！
  - 因为静态成员函数并不具体作用与某个对象!因此，静态成员函数的真实的参数的个数，就是程序中写出的参数个数
  
## 常量对象、常量成员函数和常引用
- 如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加const关键字
- 在类的成员函数说明后面可以加const关键字，则该成员函数成为常量成员函数
- 常量成员函数执行期间不应修改其所作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数(静态成员函数除外）
- 两个成员函数，名字和参数表都一样，但是一个是const,一个不是，算重载

- 引用前面可以加const关键字，成为常引用。不能通过常引用，修改其引用的变量

```
#include <iostream>
using namespace std;

class Sample {
public:
    int value;
    void getValue() const;
    void func() {};
    Sample() {};
};

void Sample::getValue() const {
    value = 0; //error 常量成员函数中不能修改成员变量的值
    func(); //error 不能调用非常量成员函数
}

int main {
    const Sample a;
    a.value = 100; //error, 常量对象不可被修改
    a.func(); //error, 常量对象中不可执行非常量成员函数
    a.getValue(); //ok, 常量对象中执行常量成员函数
    return 0;
}

```

## 运算符重载
- 对已有的运算符赋予多重的含义
- 使同一运算符作用于不同类型的数据时->不同类型的行为
- 运算符重载的实质是函数重载

```
返回值类型 operator 运算符 （形参表）
{
    ...
}
```
- 在程序编译时:
  - 把含运算符的表达式->对运算符函数的调用
  - 把运算符的操作数->运算符函数的参数
  - 运算符被多次重载时, 根据实参的类型决定调用哪个运算符函数
  - 运算符可以被重载成普通函数
  - 也可以被重载成类的成员函数

## 赋值运算符的重载
- 赋值运算符两边的类型可以不匹配
  - 把一个 int类型变量 赋值给一个 Complex对象
  - 把一个 char * 类型的字符串 赋值给一个 字符串对象
- 需要 重载赋值运算符 ‘=’
- 赋值运算符 “=” 只能重载为成员函数

- 重载赋值运算符的意义 – 浅复制和深复制
  - S1 = S2;
  - 浅复制/浅拷贝
    - 执行逐个字节的复制工作
    - 将一个对象中指针变量指向的内容,复制到另一个对象中指针成员对象指向的地方
```
class String{
    char* str;
public:
    String(): str(NULL) {}
    const char* c_str() {return str;}
    char* operator = (const char* s);
    String& operator = (const String& s) {
        if(str == s.str) return *this;
        if(str) delete[] str;
        if(s.str) {
            str = new char[strlen(s.str)+1];
            strcpy(str, s.str);
        }
        else {
            str = NULL;
        }
        return *this;
    }
    ~String();
};

char* String::operator = (const char* s) {
    if(str) delete[] str;
    if(s) {
        str = new char[strlen(s)+1];
        strcpy(str, s);
    }
    else {
        str = NULL;
    }
    return str;
}

String::~String() {
    if(str) delete[] str;
}
```

## 继承和派生
- 继承：在定义一个新的类B时，如果该类与某个已有的类A相似(指的是B拥有A的全部特点)，那么就可以把A作为一个基类，而把B作为基类的一个派生类(也称子类)
- 派生类是通过对基类进行修改和扩充得到的, 在派生类中，可以扩充新的成员变量和成员函数
- 派生类一经定义后，可以独立使用，不依赖于基类
- 派生类拥有基类的全部成员函数和成员变量，不论是private、protected、public
  - 在派生类的各个成员函数中，不能访问基类中的private成员
- 派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。在派生类对象中，包含着基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。

## 继承关系和复合关系
- 继承：“是”关系
  – 基类 A，B是基类A的派生类。
  – 逻辑上要求：“一个B对象也是一个A对象”。
- 复合：“有”关系
  – 类C中“有”成员变量k，k是类D的对象，则C和D是复合关系
  – 一般逻辑上要求：“D对象是C对象的固有属性或组成部分” 
 
## 基类/派生类同名成员与Protected关键字
- 基类的private成员: 可以被下列函数访问
  - 基类的成员函数
  - 基类的友员函数
- 基类的public成员: 可以被下列函数访问
  - 基类的成员函数
  - 基类的友员函数
  - 派生类的成员函数
  - 派生类的友员函数
  - 其他的函数
- 基类的protected成员: 可以被下列函数访问
  - 基类的成员函数
  - 基类的友员函数
  - 派生类的成员函数可以访问当前对象的基类的保护成员

## 派生类的构造函数
- 派生类对象 包含 基类对象
- 执行派生类构造函数之前, 先执行基类的构造函数
```
# 派生类交代基类初始化, 具体形式:
构造函数名(形参表): 基类名(基类构造函数实参表)
{
}
```
- 在创建派生类的对象时,
  - 需要调用基类的构造函数: 初始化派生类对象中从基类继承的成员
  - 在执行一个派生类的构造函数之前,总是先执行基类的构造函数
- 派生类的析构函数被执行时, 执行完派生类的析构函数后, 自动调用基类的析构函数

- 创建派生类的对象时, 执行派生类的构造函数之前:
  - 调用基类的构造函数: 初始化派生类对象中从基类继承的成员
  - 调用成员对象类的构造函数: 初始化派生类对象中成员对象
- 执行完派生类的析构函数后:
  - 调用成员对象类的析构函数
  - 调用基类的析构函数
- 析构函数的调用顺序与构造函数的调用顺序相反

## public继承的赋值兼容规则
- 派生类的对象可以赋值给基类对象
  - b = d;
- 派生类对象可以初始化基类引用
  - base & br = d;
- 派生类对象的地址可以赋值给基类指针
  - base * pb = & d;
- 如果派生方式是 private或protected，则上述三条不可行

## 虚函数和多态
- 在类的定义中，前面有 virtual 关键字的成员函数就是虚函数
- virtual 关键字只用在类定义里的函数声明中，写函数体时不用

- 多态的表现形式一:
  - 派生类的指针可以赋给基类指针
  - 通过基类指针调用基类和派生类中的同名虚函数时:
    - 若该指针指向一个基类的对象，那么被调用是基类的虚函数；
    - 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。
- 多态的表现形式二:
  - 派生类的对象可以赋给基类引用
  - 通过基类引用调用基类和派生类中的同名虚函数时:
    - 若该引用引用的是一个基类的对象，那么被调用是基类的虚函数；
    - 若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。

## 多态的实现原理
- “多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定 ---- 这叫“动态联编”
- 虚函数表
  - 每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。多出来的4个字节就是用来放虚函数表的地址的

## 虚析构函数
- 通过基类的指针删除派生类对象时 -> 只调用基类的析构函数
- 解决办法:
  - 把基类的析构函数声明为virtual
  - 派生类的析构函数 virtual可以不进行声明
  - 通过基类的指针删除派生类对象时
    - 首先调用派生类的析构函数
    - 然后调用基类的析构函数
- 类如果定义了虚函数, 则最好将析构函数也定义成虚函数
- Note: 不允许以虚函数作为构造函数

